from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from modules.dats import DatNode
    from modules.config import Config
    from modules.titletools import Removes

from modules.title_selection.overrides_post_filters import user_override_post_filter_match
from modules.titletools import TitleTools, TraceTools
from modules.utils import eprint


def includes(
    processed_titles: dict[str, set[DatNode]],
    original_titles: dict[str, set[DatNode]],
    original_titles_with_clonelist: dict[str, set[DatNode]],
    config: Config,
    removes: Removes,
) -> dict[str, set[DatNode]]:
    """
    Works through a dict of DatNodes and adds titles that match user criteria.

    Args:
        processed_titles (dict[str, set[DatNode]]): A work in progress dictionary
        of DatNodes, originally populated from the input DAT and actively being worked
        on by Retool.

        original_titles (dict[str, set[DatNode]]): A dictionary of DatNodes that
        represents all the titles found in the original input DAT, untouched by
        Retool's processes. Included titles are recovered from here.

        original_titles_with_clonelist (dict[str, list[DatNode]]): A dictionary of
        DatNodes that represents all the titles found in the original input DAT,
        processed to take the `variants` object in the relevant clone list into
        account. This makes sure the correct title relationships are established if
        someone's used the `<>` tags in their includes to try and include related
        titles as well.

        config (Config): The Retool config object.

        removes (Removes): The Retool removes object, which contains and categorizes
        all the titles that have been removed from consideration. Is used for stats
        and other output files generated by Retool.

    Returns:
            dict[str, set[DatNode]]: A dictionary of DatNodes with titles added based
            on user criteria.
    """
    eprint('• Applying user includes... ')
    # Set up title tracking
    report_on_match: bool = False

    if config.user_input.trace:
        for titles in processed_titles.values():
            report_on_match = TraceTools.trace_enable(set(titles), config.user_input.trace)

            if report_on_match:
                break

    if report_on_match:
        eprint('\n\nStage: Inclusions', level='warning')

    include_titles: set[DatNode] = set()

    for titles in original_titles.values():
        for title in titles:
            if user_override_post_filter_match(title, config.system_include):
                if not any(d.full_name == title.full_name for d in include_titles):
                    title.include_reason = 'User system include'
                    include_titles.add(title)
                    config.stats.system_include_count += 1

            if user_override_post_filter_match(
                title, config.global_include
            ) and not user_override_post_filter_match(title, config.system_exclude):
                if not any(d.full_name == title.full_name for d in include_titles):
                    title.include_reason = 'User global include'
                    include_titles.add(title)
                    config.stats.global_include_count += 1

    if config.user_input.trace:
        report_on_match = TraceTools.trace_enable(include_titles, config.user_input.trace)

    system_includes: set[DatNode] = {
        x for x in include_titles if x.include_reason == 'User system include'
    }
    global_includes: set[DatNode] = {
        x for x in include_titles if x.include_reason == 'User global include'
    }

    if system_includes and report_on_match:
        TraceTools.trace_title('REF0047', [], system_includes, keep_remove=False)
    if global_includes and report_on_match:
        TraceTools.trace_title('REF0048', [], global_includes, keep_remove=False)

    # Include titles related to includes
    if any(x for x in include_titles if x.exclude_include_related):
        include_related: set[DatNode] = set()

        for include_title in include_titles:
            if include_title.exclude_include_related:
                found_include_title: set[DatNode] = TitleTools.find_title(
                    include_title.full_name,
                    'full',
                    processed_titles,
                    set(),
                    config,
                    deep_search=True,
                )

                for title in original_titles_with_clonelist[
                    next(iter(found_include_title)).group_name
                ]:
                    if not (
                        any(d.full_name == title.full_name for d in include_titles)
                        or any(d.full_name == title.full_name for d in include_related)
                    ):
                        if include_title.include_reason == 'User system include':
                            config.stats.system_include_count += 1
                        elif include_title.include_reason == 'User global include':
                            config.stats.global_include_count += 1

                        include_related.add(title)

        if config.user_input.trace:
            report_on_match = TraceTools.trace_enable(include_related, config.user_input.trace)

        if report_on_match:
            TraceTools.trace_title('REF0066', [], include_related, keep_remove=False)

        include_titles = include_titles | include_related

    # Remove the title if it already exists in processed_titles, then insert the recovered version
    # of the title
    for include_title in include_titles:
        found_current_titles: set[DatNode] = TitleTools.find_title(
            include_title.full_name, 'full', processed_titles, set(), config, deep_search=True
        )

        if found_current_titles:
            for found_current_title in found_current_titles:
                # Remove the cloneof property if it exists
                found_current_title.cloneof = ''

                # Remove the title from the group if found
                if found_current_title.group_name in processed_titles:
                    if found_current_title in processed_titles[found_current_title.group_name]:
                        processed_titles[found_current_title.group_name].remove(found_current_title)

        if include_title.group_name not in processed_titles:
            processed_titles[include_title.group_name] = set()

        processed_titles[include_title.group_name].add(include_title)

        # Make sure the recovered title isn't in the removes list
        removes_temp = removes.__dict__.copy()

        for reason, removed_titles in removes_temp.items():
            new_removed_titles: set[DatNode] = {
                x for x in removed_titles if x.full_name != include_title.full_name
            }
            setattr(removes, reason, new_removed_titles)

    eprint('• Applying user includes... done.', overwrite=True)

    return processed_titles
