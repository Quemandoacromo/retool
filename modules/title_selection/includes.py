from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from modules.config.config import Config
    from modules.dat.process_dat import DatNode
    from modules.titletools import Removes

from modules.title_selection.overrides_post_filters import user_override_post_filter_match
from modules.titletools import TraceTools
from modules.utils import eprint


def includes(
    processed_titles: dict[str, set[DatNode]],
    quick_lookup: dict[str, dict[str, set[DatNode]]],
    config: Config,
    removed_titles: Removes,
) -> dict[str, set[DatNode]]:
    """
    Works through a dict of DatNodes and adds titles that match user criteria.

    Args:
        processed_titles (dict[str, set[DatNode]]): A work in progress dictionary of
            DatNodes, originally populated from the input DAT and actively being worked on
            by Retool.

        quick_lookup (dict[str, set[DatNode]]): A dictionary keyed by multiple title
            properties that enables quick lookup of titles. Due to the way Python
            references variables, changes made here are also reflected in
            `processed_titles`.

        config (Config): The Retool config object.

        removed_titles (Removes): The Retool removes object, which contains and
            categorizes all the titles that have been removed from consideration. It is
            used for recovering titles defined by user includes, stats, and other output
            files generated by Retool.

    Returns:
            dict (dict[str, set[DatNode]]): A dictionary of DatNodes with titles added
            based on user criteria.
    """
    eprint('• Applying user includes... ')
    # Set up title tracking
    report_on_match: bool = False

    if config.user_input.trace:
        for titles in removed_titles.__dict__.values():
            report_on_match = TraceTools.trace_enable(titles, config.user_input.trace)

            if report_on_match:
                break

    if report_on_match:
        eprint('\n\nStage: Inclusions', level='warning')

    include_titles: set[DatNode] = set()

    def user_override_include(titles: set[DatNode], title_property: str) -> None:
        """
        Searches for user includes in a given set of DatNodes.

        Args:
            titles (set[DatNode]): A set of DatNodes to look through and recover titles
                from.

            title_property (str): A filty hack. Pass `full_name` to match all titles. Pass
                `cloneof` to only match titles that are clones.
        """
        for title in titles:
            # Find system includes
            if user_override_post_filter_match(title, config.system_include):
                if not any(d.full_name == title.full_name for d in include_titles):
                    if title.__getattribute__(title_property):
                        title.include_reason = 'User system include'
                        title.cloneof = ''
                        title.exclude_reason = ''
                        include_titles.add(title)
                        config.stats.system_include_count += 1

            # Find global includes
            if user_override_post_filter_match(
                title, config.global_include
            ) and not user_override_post_filter_match(title, config.system_exclude):
                if not any(d.full_name == title.full_name for d in include_titles):
                    if title.__getattribute__(title_property):
                        title.include_reason = 'User global include'
                        title.cloneof = ''
                        title.exclude_reason = ''
                        include_titles.add(title)
                        config.stats.global_include_count += 1

    for titles in removed_titles.__dict__.values():
        user_override_include(titles, 'full_name')

    for titles in processed_titles.values():
        user_override_include(titles, 'cloneof')

    if config.user_input.trace:
        report_on_match = TraceTools.trace_enable(include_titles, config.user_input.trace)

    system_includes: set[DatNode] = {
        x for x in include_titles if x.include_reason == 'User system include'
    }
    global_includes: set[DatNode] = {
        x for x in include_titles if x.include_reason == 'User global include'
    }

    if system_includes and report_on_match:
        TraceTools.trace_title('REF0047', [], system_includes, keep_remove=False)
    if global_includes and report_on_match:
        TraceTools.trace_title('REF0048', [], global_includes, keep_remove=False)

    # Include titles related to includes
    if any(x for x in include_titles if x.exclude_include_related):
        include_related: set[DatNode] = set()
        group_names: set[str] = set()

        for include_title in include_titles:
            if include_title.exclude_include_related:
                group_names.add(include_title.group_name)

        def user_override_include_related(
            titles: set[DatNode], group_name: str, title_property: str
        ) -> None:
            """
            Searches for titles related to user includes in a given set of DatNodes.

            Args:
                titles (set[DatNode]): A set of DatNodes to look through and recover
                    titles from.

                group_name (str): The name for a group of related titles.

                title_property (str): A filty hack. Pass `full_name` to match all titles.
                    Pass `cloneof` to only match titles that are clones.
            """
            for title in titles:
                if title.full_name not in [x.full_name for x in include_titles]:
                    if title.group_name == group_name:
                        if title.__getattribute__(title_property):
                            title.cloneof = ''
                            title.exclude_reason = ''
                            include_related.add(title)

                            if include_title.include_reason == 'User system include':
                                config.stats.system_include_count += 1
                            elif include_title.include_reason == 'User global include':
                                config.stats.global_include_count += 1

        # Get related includes out of the `removed_titles` object
        for group_name in group_names:
            user_override_include_related(
                {
                    title
                    for removed_type in removed_titles.__dict__.values()
                    for title in removed_type
                },
                group_name,
                'full_name',
            )

        # Get related includes out of the `processed_titles` object
        for group_name in group_names:
            if group_name in processed_titles:
                user_override_include_related(processed_titles[group_name], group_name, 'cloneof')

        if config.user_input.trace:
            report_on_match = TraceTools.trace_enable(include_related, config.user_input.trace)

        if report_on_match:
            TraceTools.trace_title('REF0066', [], include_related, keep_remove=False)

        include_titles = include_titles | include_related

    # Remove the title if it already exists in processed_titles, then insert the recovered
    # version of the title
    for include_title in include_titles:
        found_current_titles: set[DatNode] = set()

        if include_title.full_name in quick_lookup['full_name_index']:
            found_current_titles = quick_lookup['full_name_index'][include_title.full_name]

        if found_current_titles:
            for found_current_title in found_current_titles:
                # Remove the title from the group if found
                if found_current_title.group_name in processed_titles:
                    if found_current_title in processed_titles[found_current_title.group_name]:
                        processed_titles[found_current_title.group_name].remove(found_current_title)

        if include_title.group_name not in processed_titles:
            processed_titles[include_title.group_name] = set()

        processed_titles[include_title.group_name].add(include_title)

        removed_titles_temp = {
            title for removed_type in removed_titles.__dict__.values() for title in removed_type
        }.copy()

        # Make sure the recovered title isn't in the removes list
        for title in removed_titles_temp:
            if title.full_name == include_title.full_name:
                for removed_type in removed_titles.__dict__:
                    if title in removed_titles.__dict__[removed_type]:
                        removed_titles.__dict__[removed_type].remove(title)

    eprint('• Applying user includes... done.', overwrite=True)

    return processed_titles
