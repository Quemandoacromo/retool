from __future__ import annotations

import re
from copy import deepcopy
from re import Pattern
from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from modules.dats import DatNode
    from modules.config import Config

from modules.utils import Font, eprint, pattern2string


class Removes:
    def __init__(self) -> None:
        """Creates an object that contains titles that have been removed."""
        self.add_ons_removes: set[DatNode] = set()
        self.aftermarket_removes: set[DatNode] = set()
        self.applications_removes: set[DatNode] = set()
        self.audio_removes: set[DatNode] = set()
        self.bad_dumps_removes: set[DatNode] = set()
        self.bios_removes: set[DatNode] = set()
        self.bonus_discs_removes: set[DatNode] = set()
        self.coverdiscs_removes: set[DatNode] = set()
        self.demos_removes: set[DatNode] = set()
        self.educational_removes: set[DatNode] = set()
        self.games_removes: set[DatNode] = set()
        self.manuals_removes: set[DatNode] = set()
        self.mia_removes: set[DatNode] = set()
        self.multimedia_removes: set[DatNode] = set()
        self.pirate_removes: set[DatNode] = set()
        self.preproduction_removes: set[DatNode] = set()
        self.promotional_removes: set[DatNode] = set()
        self.unlicensed_removes: set[DatNode] = set()
        self.video_removes: set[DatNode] = set()
        self.clone_list_removes: set[DatNode] = set()
        self.language_removes: set[DatNode] = set()
        self.region_removes: set[DatNode] = set()
        self.system_excludes: set[DatNode] = set()
        self.global_excludes: set[DatNode] = set()
        self.global_filter_removes: set[DatNode] = set()
        self.system_filter_removes: set[DatNode] = set()


class IncludeExcludeTools:
    """Methods for applying user includes/excludes to a list of DatNode titles."""

    @staticmethod
    def excludes(
        processed_titles: dict[str, set[DatNode]], config: Config, removes: Removes
    ) -> dict[str, set[DatNode]]:
        """
        Works through a dict of DatNodes and removes nodes that match user criteria.

        Args:
            processed_titles (dict[str, set[DatNode]]): A work in progress dictionary
            of DatNodes, originally populated from the input DAT and actively being worked
            on by Retool.

            config (Config): The Retool config object.

            removes (Removes): The Retool removes object, which contains and categorizes
            all the titles that have been removed from consideration. Is used for stats
            and other output files generated by Retool.

        Returns:
            `dict[str, set[DatNode]]` A dictionary of DatNodes with titles excluded
            based on user criteria.
        """
        eprint('* Applying category and user excludes... ', sep=' ', end='', flush=True)

        # Set up title tracking
        report_on_match: bool = False

        if config.user_input.trace:
            for titles in processed_titles.values():
                report_on_match = TraceTools.trace_enable(set(titles), config.user_input.trace)

                if report_on_match:
                    break

        if report_on_match:
            eprint(f'\n\n{Font.heading_bold}Stage: Exclusions{Font.end}')

        exclude_categories: set[tuple[str, str]] = set()
        exclude_titles_regex: set[tuple[Pattern[str], str, str]] = set()

        if config.user_input.no_add_ons:
            exclude_categories.add(('Add-Ons', 'addons_count'))
        if config.user_input.no_aftermarket:
            exclude_titles_regex.add((config.regex.aftermarket, 'aftermarket_count', 'Aftermarket'))
        if config.user_input.no_applications:
            exclude_categories.add(('Applications', 'applications_count'))
            exclude_titles_regex.add((config.regex.programs, 'applications_count', 'Applications'))
        if config.user_input.no_audio:
            exclude_categories.add(('Audio', 'audio_count'))
        if config.user_input.no_bad_dumps:
            exclude_titles_regex.add((config.regex.bad, 'bad_dumps_count', 'Bad Dumps'))
        if config.user_input.no_bios:
            exclude_categories.add(('BIOS', 'bios_count'))
            exclude_categories.add(('Console', 'bios_count'))
            exclude_titles_regex.add((config.regex.bios, 'bios_count', 'BIOS'))
        if config.user_input.no_bonus_discs:
            exclude_categories.add(('Bonus Discs', 'bonus_discs_count'))
        if config.user_input.no_coverdiscs:
            exclude_categories.add(('Coverdiscs', 'coverdiscs_count'))
        if config.user_input.no_demos:
            exclude_categories.add(('Demos', 'demos_count'))
            for demo in config.regex.demos:
                exclude_titles_regex.add((demo, 'demos_count', 'Demos'))
        if config.user_input.no_educational:
            exclude_categories.add(('Educational', 'educational_count'))
        if config.user_input.no_games:
            exclude_categories.add(('Games', 'games_count'))
        if config.user_input.no_manuals:
            exclude_categories.add(('Manuals', 'manuals_count'))
            exclude_titles_regex.add((config.regex.manuals, 'manuals_count', 'Manuals'))
        if config.user_input.no_multimedia:
            exclude_categories.add(('Multimedia', 'multimedia_count'))
            exclude_titles_regex.add((config.regex.multimedia, 'multimedia_count', 'Multimedia'))
        if config.user_input.no_pirate:
            exclude_categories.add(('Pirate', 'pirate_count'))
            exclude_titles_regex.add((config.regex.pirate, 'pirate_count', 'Pirate'))
        if config.user_input.no_preproduction:
            exclude_categories.add(('Preproduction', 'preproduction_count'))
            for preproduction in config.regex.preproduction:
                exclude_titles_regex.add((preproduction, 'preproduction_count', 'Preproduction'))
        if config.user_input.no_promotional:
            exclude_categories.add(('Promotional', 'promotional_count'))
            exclude_titles_regex.add((config.regex.promotional, 'promotional_count', 'Promotional'))
        if config.user_input.no_unlicensed:
            exclude_categories.add(('Unlicensed', 'unlicensed_count'))
            exclude_titles_regex.add((config.regex.unlicensed, 'unlicensed_count', 'Unlicensed'))
        if config.user_input.no_video:
            exclude_categories.add(('Video', 'video_count'))
            for video in config.regex.video:
                exclude_titles_regex.add((video, 'video_count', 'Video'))

        temp_dict = processed_titles.copy()
        exclude_titles: set[DatNode] = set()
        exclude_related: set[DatNode] = set()
        count: int = 0

        for titles in temp_dict.values():
            if config.user_input.trace:
                report_on_match = TraceTools.trace_enable(set(titles), config.user_input.trace)

            for title in titles:
                # Category excludes
                category: str
                category_remove_name: str
                category_removes: set[DatNode]
                title_found: bool = False

                for exclude_category in [x for x in exclude_categories if x[0] in title.categories]:
                    if report_on_match:
                        TraceTools.trace_title(
                            'REF0042', [', '.join(title.categories)], {title}, keep_remove=False
                        )

                    if title not in exclude_titles and title.group_name in processed_titles:
                        # Superset titles can be in multiple groups, so deduping needs to be done
                        # for exclude stats
                        if not any(d.full_name == title.full_name for d in exclude_titles):
                            count = getattr(config.stats, exclude_category[1])
                            count += 1
                            setattr(config.stats, exclude_category[1], count)

                            exclude_titles.add(title)

                            category = exclude_category[0]

                            if category == 'Console':
                                category = 'BIOS'

                            title.exclude_reason = f'Category exclude, {category}'

                            category_remove_name = f'{category.lower()}_removes'.replace(
                                ' ', '_'
                            ).replace('-', '_')

                            category_removes = getattr(removes, category_remove_name)
                            category_removes.add(title)
                            title_found = True

                            setattr(removes, category_remove_name, category_removes)

                if title_found:
                    continue

                # Regex excludes
                for exclude_regex in [
                    x for x in exclude_titles_regex if re.search(x[0], title.full_name)
                ]:
                    if report_on_match:
                        TraceTools.trace_title(
                            'REF0044',
                            [
                                str(exclude_regex[0])
                                .replace('re.compile(', '')
                                .replace(', re.IGNORECASE)', '')
                            ],
                            {title},
                            keep_remove=False,
                        )

                    if title not in exclude_titles and title.group_name in processed_titles:
                        # Superset titles can be in multiple groups, so deduping needs to be done
                        # for exclude stats
                        if not any(d.full_name == title.full_name for d in exclude_titles):
                            count = getattr(config.stats, exclude_regex[1])
                            count += 1
                            setattr(config.stats, exclude_regex[1], count)

                            exclude_titles.add(title)

                            title.exclude_reason = f'Category exclude, {exclude_regex[2]}'

                            category = exclude_regex[2]
                            category_remove_name = f'{category.lower()}_removes'.replace(
                                ' ', '_'
                            ).replace('-', '_')

                            category_removes = getattr(removes, category_remove_name)
                            category_removes.add(title)
                            title_found = True

                            setattr(removes, category_remove_name, category_removes)

                if title_found:
                    continue

                # MIA excludes
                if config.user_input.no_mia:
                    if title.is_mia:
                        # Superset titles can be in multiple groups, so deduping needs to be done
                        # for exclude stats
                        if not any(d.full_name == title.full_name for d in exclude_titles):
                            count = config.stats.mia_count
                            count += 1
                            setattr(config.stats, 'mia_count', count)

                            if report_on_match:
                                TraceTools.trace_title('REF0062', [], {title}, keep_remove=False)

                            exclude_titles.add(title)
                            title.exclude_reason = 'Known MIA title'
                            removes.mia_removes.add(title)
                            title_found = True

                            if report_on_match:
                                TraceTools.trace_title(
                                    'REF0044',
                                    [
                                        str(exclude_regex[0])
                                        .replace('re.compile(', '')
                                        .replace(', re.IGNORECASE)', '')
                                    ],
                                    {title},
                                    keep_remove=False,
                                )

                if title_found:
                    continue

                # Custom overrides excludes
                if not config.user_input.no_overrides:
                    if config.system_exclude:
                        if IncludeExcludeTools.user_override_match(
                            title, config.system_exclude
                        ) and not IncludeExcludeTools.user_override_match(
                            title, config.system_include
                        ):
                            if report_on_match:
                                TraceTools.trace_title('REF0045', [], {title}, keep_remove=False)

                            if title not in exclude_titles and title.group_name in processed_titles:
                                # Superset titles can be in multiple groups, so deduping needs to be done
                                # for exclude stats
                                if not any(d.full_name == title.full_name for d in exclude_titles):
                                    config.stats.system_exclude_count += 1

                                    exclude_titles.add(title)

                                    title.exclude_reason = 'User system exclude'
                                    removes.system_excludes.add(title)
                        elif IncludeExcludeTools.user_override_match(
                            title, config.system_exclude
                        ) and IncludeExcludeTools.user_override_match(title, config.system_include):
                            if report_on_match:
                                TraceTools.trace_title('REF0050', [], {title}, keep_remove=False)

                    if config.global_exclude:
                        if (
                            IncludeExcludeTools.user_override_match(title, config.global_exclude)
                            and not IncludeExcludeTools.user_override_match(
                                title, config.global_include
                            )
                            and not IncludeExcludeTools.user_override_match(
                                title, config.system_include
                            )
                        ):
                            if report_on_match:
                                TraceTools.trace_title('REF0046', [], {title}, keep_remove=False)

                            if title not in exclude_titles and title.group_name in processed_titles:
                                # Superset titles can be in multiple groups, so deduping needs to be done
                                # for exclude stats
                                if not any(d.full_name == title.full_name for d in exclude_titles):
                                    config.stats.global_exclude_count += 1

                                    exclude_titles.add(title)

                                    title.exclude_reason = 'User global exclude'
                                    removes.global_excludes.add(title)
                        elif IncludeExcludeTools.user_override_match(
                            title, config.global_exclude
                        ) and IncludeExcludeTools.user_override_match(title, config.global_include):
                            if report_on_match:
                                TraceTools.trace_title('REF0051', [], {title}, keep_remove=False)
                        elif IncludeExcludeTools.user_override_match(
                            title, config.global_exclude
                        ) and IncludeExcludeTools.user_override_match(title, config.system_include):
                            if report_on_match:
                                TraceTools.trace_title('REF0052', [], {title}, keep_remove=False)

        if not config.user_input.no_overrides:
            # Find related exclusions based on overrides
            for title in exclude_titles:
                if title.exclude_include_related:
                    for related_title in processed_titles[title.group_name]:
                        if not (
                            any(d.full_name == related_title.full_name for d in exclude_titles)
                            or any(d.full_name == related_title.full_name for d in exclude_related)
                        ):
                            if title.exclude_reason == 'User system exclude':
                                config.stats.system_exclude_count += 1

                                related_title.exclude_reason = 'Related to user system excludes'
                                removes.system_excludes.add(related_title)
                            elif title.exclude_reason == 'User global exclude':
                                config.stats.global_exclude_count += 1

                                related_title.exclude_reason = 'Related to user global excludes'

                                removes.global_excludes.add(related_title)

                            exclude_related.add(related_title)

        exclude_titles = exclude_titles | exclude_related

        # Remove excluded titles
        remove_titles: set[DatNode] = set()
        found_titles: set[DatNode] = set()

        for exclude_title in exclude_titles:
            found_titles = TitleTools.find_title(
                exclude_title.full_name, 'full', temp_dict, set(), config, deep_search=True
            )

            for found_title in found_titles:
                if found_title.group_name in processed_titles:
                    for title in processed_titles[found_title.group_name]:
                        if exclude_title.full_name == title.full_name:
                            remove_titles.add(title)

        for title in remove_titles:
            processed_titles[title.group_name].remove(title)

        # Clean up empty groups
        for group_name in temp_dict.keys():
            if not processed_titles[group_name]:
                del processed_titles[group_name]

        eprint('done.')

        return processed_titles

    @staticmethod
    def filter_languages(
        processed_titles: dict[str, set[DatNode]], config: Config, removes: Removes
    ) -> dict[str, set[DatNode]]:
        """
        Filters titles in a dict of DatNodes for languages as defined by the user.

        Args:
            processed_titles (dict[str, set[DatNode]]): A work in progress dictionary
            of DatNodes, originally populated from the input DAT and actively being worked
            on by Retool.

            config (Config): The Retool config object.

            removes (Removes): The Retool removes object, which contains and categorizes
            all the titles that have been removed from consideration. Is used for stats
            and other output files generated by Retool.

        Returns:
            `dict[str, set[DatNode]]` A dictionary of DatNodes with titles filtered
            based on languages.
        """
        eprint('* Removing titles without specified languages... ', sep=' ', end='', flush=True)

        # Set up title tracking
        report_on_match: bool = False

        if config.user_input.trace:
            for titles in processed_titles.values():
                report_on_match = TraceTools.trace_enable(set(titles), config.user_input.trace)

                if report_on_match:
                    break

        if report_on_match:
            eprint(f'\n\n{Font.warning_bold}Stage: Filter languages{Font.end}')

        temp_dict = processed_titles.copy()
        supported_languages_all: set[DatNode] = set()
        languages_count: set[str] = set()

        # Check if a system config is in play for languages
        language_order: list[str] = []

        if config.languages_filter:
            language_order = config.language_order_user

            if config.system_language_order_user:
                if {'override': 'true'} in config.system_language_order_user:
                    language_order = [
                        str(x) for x in config.system_language_order_user if 'override' not in x
                    ]

                    if not config.system_languages_user_found:
                        # If there's a global language order, assume the user's preference for them and grab those languages.
                        if config.language_order_user:
                            language_order.extend(
                                [x for x in config.language_order_user if x not in language_order]
                            )

                        # Now add the rest of the languages in
                        language_order.extend(
                            [x for x in config.languages.values() if x not in language_order]
                        )
        else:
            language_order = config.region_order_languages_user

        for group_name, titles in temp_dict.items():
            if config.user_input.trace:
                report_on_match = TraceTools.trace_enable(set(titles), config.user_input.trace)

            supported_languages: set[DatNode] = set()

            for title in titles:
                # Add titles with unknown languages
                if not title.languages:
                    if title not in supported_languages:
                        supported_languages.add(title)
                        # Superset titles can be in multiple groups, so deduping needs to be done
                        # for exclude stats
                        if not any(d.full_name == title.full_name for d in supported_languages_all):
                            languages_count.add(title.full_name)
                        continue

                # Add titles that support user-defined languages
                for language_code in language_order:
                    for language in title.languages:
                        if re.search(language_code, language):
                            if title not in supported_languages:
                                supported_languages.add(title)

            report_titles: set[DatNode] = {
                x for x in processed_titles[group_name] if x not in supported_languages
            }

            if report_on_match and report_titles:
                TraceTools.trace_title(
                    'REF0049', [', '.join(language_order)], report_titles, keep_remove=False
                )

            # Superset titles can be in multiple groups, so deduping needs to be done for exclude stats
            languages_count = languages_count | {
                x.full_name for x in processed_titles[group_name] if x not in supported_languages
            }

            # Track removed titles
            for title in [x for x in processed_titles[group_name] if x not in supported_languages]:
                title.exclude_reason = 'Language remove'
                removes.language_removes.add(title)

            processed_titles[group_name] = set(supported_languages)

            # Clean up empty groups
            if not processed_titles[group_name]:
                del processed_titles[group_name]

        # Add removed titles due to language filters to the stats
        config.stats.languages_count = len(languages_count)

        eprint('done.')

        return processed_titles

    @staticmethod
    def filter_regions(
        processed_titles: dict[str, set[DatNode]], config: Config, removes: Removes
    ) -> dict[str, set[DatNode]]:
        """
        Filters titles in a dict of DatNodes for regions as defined by the user.

        Args:
            processed_titles (dict[str, set[DatNode]]): A work in progress dictionary
            of DatNodes, originally populated from the input DAT and actively being worked
            on by Retool.

            config (Config): The Retool config object.

            removes (Removes): The Retool removes object, which contains and categorizes
            all the titles that have been removed from consideration. Is used for stats
            and other output files generated by Retool.

        Returns:
            dict[str, set[DatNode]]: A dictionary of DatNodes with titles filtered
            based on regions.
        """
        eprint('* Removing titles without specified regions... ', sep=' ', end='', flush=True)

        temp_dict = processed_titles.copy()
        regions_count: set[str] = set()

        # Check if a system config is in play
        region_order: list[str] = config.region_order_user

        if config.system_region_order_user:
            if {'override': 'true'} in config.system_region_order_user:
                region_order = [
                    str(x) for x in config.system_region_order_user if 'override' not in x
                ]

        for group_name, titles in temp_dict.items():
            supported_regions: set[DatNode] = set()

            for title in titles:
                for region in region_order:
                    if region in title.regions:
                        supported_regions.add(title)

            # Exception to track stats later for superset titles, which can be in multiple groups
            regions_count = regions_count | {
                x.full_name for x in processed_titles[group_name] if x not in supported_regions
            }

            # Track removed titles
            for title in [x for x in processed_titles[group_name] if x not in supported_regions]:
                title.exclude_reason = 'Region remove'
                removes.region_removes.add(title)

            processed_titles[group_name] = set(supported_regions)

            # Clean up empty groups
            if not processed_titles[group_name]:
                del processed_titles[group_name]

        # Add removed titles due to region filters to the stats
        config.stats.regions_count = len(regions_count)

        eprint('done.')

        return processed_titles

    @staticmethod
    def includes(
        processed_titles: dict[str, set[DatNode]],
        original_titles: dict[str, set[DatNode]],
        original_titles_with_clonelist: dict[str, set[DatNode]],
        config: Config,
        removes: Removes,
    ) -> dict[str, set[DatNode]]:
        """
        Works through a dict of DatNodes and adds titles that match user criteria.

        Args:
            processed_titles (dict[str, set[DatNode]]): A work in progress dictionary
            of DatNodes, originally populated from the input DAT and actively being worked
            on by Retool.

            original_titles (dict[str, set[DatNode]]): A dictionary of DatNodes that
            represents all the titles found in the original input DAT, untouched by
            Retool's processes. Included titles are recovered from here.

            original_titles_with_clonelist (dict[str, list[DatNode]]): A dictionary of
            DatNodes that represents all the titles found in the original input DAT,
            processed to take the `variants` object in the relevant clone list into
            account. This makes sure the correct title relationships are established if
            someone's used the `<>` tags in their includes to try and include related
            titles as well.

            config (Config): The Retool config object.

            removes (Removes): The Retool removes object, which contains and categorizes
            all the titles that have been removed from consideration. Is used for stats
            and other output files generated by Retool.

        Returns:
             dict[str, set[DatNode]]: A dictionary of DatNodes with titles added based
             on user criteria.
        """
        eprint('* Applying user includes... ', sep=' ', end='', flush=True)
        # Set up title tracking
        report_on_match: bool = False

        if config.user_input.trace:
            for titles in processed_titles.values():
                report_on_match = TraceTools.trace_enable(set(titles), config.user_input.trace)

                if report_on_match:
                    break

        if report_on_match:
            eprint(f'\n\n{Font.warning_bold}Stage: Inclusions{Font.end}')

        include_titles: set[DatNode] = set()

        for titles in original_titles.values():
            for title in titles:
                if IncludeExcludeTools.user_override_match(title, config.system_include):
                    if not any(d.full_name == title.full_name for d in include_titles):
                        title.include_reason = 'User system include'
                        include_titles.add(title)
                        config.stats.system_include_count += 1

                if IncludeExcludeTools.user_override_match(
                    title, config.global_include
                ) and not IncludeExcludeTools.user_override_match(title, config.system_exclude):
                    if not any(d.full_name == title.full_name for d in include_titles):
                        title.include_reason = 'User global include'
                        include_titles.add(title)
                        config.stats.global_include_count += 1

        if config.user_input.trace:
            report_on_match = TraceTools.trace_enable(include_titles, config.user_input.trace)

        system_includes: set[DatNode] = {
            x for x in include_titles if x.include_reason == 'User system include'
        }
        global_includes: set[DatNode] = {
            x for x in include_titles if x.include_reason == 'User global include'
        }

        if system_includes and report_on_match:
            TraceTools.trace_title('REF0047', [], system_includes, keep_remove=False)
        if global_includes and report_on_match:
            TraceTools.trace_title('REF0048', [], global_includes, keep_remove=False)

        # Include titles related to includes
        if any(x for x in include_titles if x.exclude_include_related):
            include_related: set[DatNode] = set()

            for include_title in include_titles:
                if include_title.exclude_include_related:
                    found_include_title: set[DatNode] = TitleTools.find_title(
                        include_title.full_name,
                        'full',
                        processed_titles,
                        set(),
                        config,
                        deep_search=True,
                    )

                    for title in original_titles_with_clonelist[
                        next(iter(found_include_title)).group_name
                    ]:
                        if not (
                            any(d.full_name == title.full_name for d in include_titles)
                            or any(d.full_name == title.full_name for d in include_related)
                        ):
                            if include_title.include_reason == 'User system include':
                                config.stats.system_include_count += 1
                            elif include_title.include_reason == 'User global include':
                                config.stats.global_include_count += 1

                            include_related.add(title)

            if config.user_input.trace:
                report_on_match = TraceTools.trace_enable(include_related, config.user_input.trace)

            if report_on_match:
                TraceTools.trace_title('REF0066', [], include_related, keep_remove=False)

            include_titles = include_titles | include_related

        # Remove the title if it already exists in processed_titles, then insert the recovered version
        # of the title
        for include_title in include_titles:
            found_current_titles: set[DatNode] = TitleTools.find_title(
                include_title.full_name, 'full', processed_titles, set(), config, deep_search=True
            )

            if found_current_titles:
                for found_current_title in found_current_titles:
                    # Remove the cloneof property if it exists
                    found_current_title.cloneof = ''

                    # Remove the title from the group if found
                    if found_current_title.group_name in processed_titles:
                        if found_current_title in processed_titles[found_current_title.group_name]:
                            processed_titles[found_current_title.group_name].remove(
                                found_current_title
                            )

            if include_title.group_name not in processed_titles:
                processed_titles[include_title.group_name] = set()

            processed_titles[include_title.group_name].add(include_title)

            # Make sure the recovered title isn't in the removes list
            removes_temp = removes.__dict__.copy()

            for reason, removed_titles in removes_temp.items():
                new_removed_titles: set[DatNode] = {
                    x for x in removed_titles if x.full_name != include_title.full_name
                }
                setattr(removes, reason, new_removed_titles)

        eprint('done.')

        return processed_titles

    @staticmethod
    def post_filters(
        processed_titles: dict[str, set[DatNode]], config: Config, removes: Removes
    ) -> dict[str, set[DatNode]]:
        """
        Works through a dict of DatNodes and removes nodes that match user criteria.

        Args:
            processed_titles (dict[str, set[DatNode]]): A work in progress dictionary
            of DatNodes, originally populated from the input DAT and actively being worked
            on by Retool.

            config (Config): The Retool config object.

            removes (Removes): The Retool removes object, which contains and categorizes
            all the titles that have been removed from consideration. Is used for stats
            and other output files generated by Retool.

        Returns:
            dict[str, set[DatNode]]: A dictionary of DatNodes with titles excluded
            based on user criteria.
        """
        if config.system_filter:
            if {'override': 'true'} in config.system_filter:
                eprint('* Applying post filters... ', sep=' ', end='', flush=True)
        if config.global_filter:
            if {'override': 'false'} in config.system_filter:
                eprint('* Applying post filters... ', sep=' ', end='', flush=True)

        # Set up title tracking
        report_on_match: bool = False

        for titles in processed_titles.values():
            report_on_match = TraceTools.trace_enable(set(titles), config.user_input.trace)

            if report_on_match:
                break

        if report_on_match and config.user_input.trace:
            eprint(f'\n\n{Font.heading_bold}Stage: Post filters{Font.end}')

        dupe_check: set[DatNode] = set()
        filter_titles: set[tuple[str, DatNode]] = set()
        global_count: int = 0
        system_count: int = 0

        for group_name, titles in processed_titles.items():
            if config.user_input.trace:
                report_on_match = TraceTools.trace_enable(set(titles), config.user_input.trace)

            for title in titles:
                if title not in dupe_check:
                    if config.system_filter:
                        if [x for x in config.system_filter if x != {'override': 'true'}]:
                            if {'override': 'true'} in config.system_filter:
                                if title.cloneof:
                                    if not IncludeExcludeTools.user_override_match(
                                        title,
                                        [
                                            str(x)
                                            for x in config.system_filter
                                            if x != {'override': 'true'}
                                            and x != {'override': 'false'}
                                        ],
                                        post_filter=True,
                                        cloneof_check=True,
                                    ):
                                        filter_titles.add((group_name, title))

                                        # Compensate for supersets being in multiple groups for the stats and log
                                        if not any(
                                            d.full_name == title.full_name for d in dupe_check
                                        ):
                                            system_count = config.stats.system_filter_count
                                            system_count += 1
                                            setattr(
                                                config.stats, 'system_filter_count', system_count
                                            )

                                            title.exclude_reason = 'System post filter exclude'

                                            dupe_check.add(title)
                                            removes.system_filter_removes.add(title)
                                elif not IncludeExcludeTools.user_override_match(
                                    title,
                                    [
                                        str(x)
                                        for x in config.system_filter
                                        if x != {'override': 'true'} and x != {'override': 'false'}
                                    ],
                                    post_filter=True,
                                ):
                                    filter_titles.add((group_name, title))

                                    # Compensate for supersets being in multiple groups for the stats and log
                                    if not any(d.full_name == title.full_name for d in dupe_check):
                                        system_count = config.stats.system_filter_count
                                        system_count += 1
                                        setattr(config.stats, 'system_filter_count', system_count)

                                        title.exclude_reason = 'System post filter exclude'

                                        dupe_check.add(title)
                                        removes.system_filter_removes.add(title)
                                else:
                                    if report_on_match and config.user_input.trace:
                                        TraceTools.trace_title(
                                            'REF0099', [], {title}, keep_remove=False
                                        )

                    if config.global_filter:
                        if (
                            not config.system_filter
                            or {'override': 'false'} in config.system_filter
                        ):
                            if title.cloneof:
                                if not IncludeExcludeTools.user_override_match(
                                    title,
                                    config.global_filter,
                                    post_filter=True,
                                    cloneof_check=True,
                                ):
                                    filter_titles.add((group_name, title))

                                    # Compensate for supersets being in multiple groups for the stats and log
                                    if not any(d.full_name == title.full_name for d in dupe_check):
                                        global_count = config.stats.global_filter_count
                                        global_count += 1
                                        setattr(config.stats, 'global_filter_count', global_count)

                                        title.exclude_reason = 'Global post filter exclude'

                                        dupe_check.add(title)
                                        removes.global_filter_removes.add(title)
                            elif not IncludeExcludeTools.user_override_match(
                                title, config.global_filter, post_filter=True
                            ):
                                filter_titles.add((group_name, title))

                                # Compensate for supersets being in multiple groups for the stats and log
                                if not any(d.full_name == title.full_name for d in dupe_check):
                                    global_count = config.stats.global_filter_count
                                    global_count += 1
                                    setattr(config.stats, 'global_filter_count', global_count)

                                    title.exclude_reason = 'Global post filter exclude'

                                    dupe_check.add(title)
                                    removes.global_filter_removes.add(title)
                            else:
                                if report_on_match and config.user_input.trace:
                                    TraceTools.trace_title(
                                        'REF0100', [], {title}, keep_remove=False
                                    )

        # Remove the titles
        for filter_title in filter_titles:
            processed_titles[filter_title[0]].remove(filter_title[1])

        # Catch compilations
        compilation_removes: set[DatNode] = set()

        if 'retool_compilations' in processed_titles:
            for compilation_title in processed_titles['retool_compilations']:
                for filter_title in filter_titles:
                    if filter_title[1].full_name == compilation_title.full_name:
                        compilation_removes.add(compilation_title)

            for compilation_remove in compilation_removes:
                processed_titles['retool_compilations'].remove(compilation_remove)

        if config.system_filter:
            if {'override': 'true'} in config.system_filter:
                eprint('done.')
        if config.global_filter:
            if {'override': 'false'} in config.system_filter:
                eprint('done.')

        return processed_titles

    @staticmethod
    def user_override_match(
        title: DatNode,
        filter_list: list[str],
        post_filter: bool = False,
        cloneof_check: bool = False,
    ) -> bool:
        """
        Establishes what kind of match a user is trying to make with their
        overrides, whether it be relational (`<>`), regex (`/`), full match (`|`)
        or partial.

        Args:
            title (DatNode): The title to look for a match in.

            filter_list (list[str]): A list of overrides that define search criteria for
            a match.

            post_filter (bool): `False` for overrides, `True` for post filters.

            cloneof_check(bool): Set to `True` when dealing with titles that have a
            `cloneof` property.

        Returns:
            bool: Whether or not a match has been made.
        """
        match: bool = False

        for string in filter_list:
            match_string: str = string

            if cloneof_check:
                if title.cloneof:
                    if match_string.startswith('/'):
                        match = bool(re.search(match_string[1:], title.cloneof))
                    elif match_string.startswith('|'):
                        match = match_string[1:] == title.cloneof
                    else:
                        match = match_string in title.cloneof

                if match:
                    break
            else:
                if not post_filter:
                    if match_string.startswith('<') and match_string.endswith('>'):
                        match_string = match_string[1:-1]

                        title.exclude_include_related = True

                if match_string.startswith('/'):
                    match = bool(re.search(match_string[1:], title.full_name))
                elif match_string.startswith('|'):
                    match = match_string[1:] == title.full_name
                else:
                    match = match_string in title.full_name

                if match:
                    break

        return match


class Regex:
    def __init__(self, LANGUAGES: str) -> None:
        """
        Regular expressions used in Retool.

        Args:
            LANGUAGES (str): All available languages to look for.
        """
        # This is set in the Config class
        self.region_order_default: Pattern[str]

        # Preproduction
        self.alpha: Pattern[str] = re.compile('\\((?:\\w*?\\s)*Alpha(?:\\s\\d+)?\\)', flags=re.I)
        self.beta: Pattern[str] = re.compile('\\((?:\\w*?\\s)*Beta(?:\\s\\d+)?\\)', flags=re.I)
        self.proto: Pattern[str] = re.compile(
            '\\((?:\\w*?\\s)*Proto(?:type)?(?:\\s\\d+)?\\)', flags=re.I
        )
        self.preprod: Pattern[str] = re.compile('\\((?:Pre-production|Prerelease)\\)', flags=re.I)
        self.dev: Pattern[str] = re.compile('\\(DEV|DEBUG\\)', flags=re.I)

        # Possibly production
        self.not_for_resale: Pattern[str] = re.compile(
            '\\((?:Hibaihin|Not for Resale)\\)', flags=re.I
        )
        self.review: Pattern[str] = re.compile('\\(Review (Code|Kit [0-9]+)\\)', re.IGNORECASE)

        # Versions
        self.version: Pattern[str] = re.compile('\\(v[\\.0-9].*?\\)', flags=re.I)
        self.version_non_parens: Pattern[str] = re.compile('(?<!^)(?<=\\(|\\s)v(?:\\d\\.?)+')
        self.long_version: Pattern[str] = re.compile(
            '\\s?(?!Version Vol\\.|Version \\(|Version$|Version -|Version \\d-)(?: - )?\\(?(?:\\((?:\\w[\\.\\-]?\\s*)*|)[Vv]ers(?:ion|ao)\\s?(?:[\\d\\.\\-]+)+[A-Za-z]?(?: (?:\\d-?)+)?.*?(?:(?:\\w[\\.\\-]?\\s*)*\\))?'
        )
        self.revision: Pattern[str] = re.compile('\\(R[eE][vV](?:[ -][0-9A-Z].*?)?\\)', flags=re.I)
        self.build: Pattern[str] = re.compile('\\(Build [0-9].*?\\)', flags=re.I)
        self.dreamcast_version: Pattern[str] = re.compile('V[0-9]{2,2} L[0-9]{2,2}')
        self.fds_version: Pattern[str] = re.compile('\\(DV [0-9].*?\\)', flags=re.I)
        self.fmtowns_pippin_version: Pattern[str] = re.compile(
            '(?<!^)\\s(?:V|Ver\\. |- Version |Version )\\d(?:\\.\\d+)?(?: L(?:evel )?\\d+[A-Z]?)?'
        )
        self.hyperscan_version: Pattern[str] = re.compile('\\(USE[0-9]\\)')
        self.nec_mastering_code: Pattern[str] = re.compile('\\((?:(?:FA|S)[A-F][ABT]S?(?:, )?)+\\)')
        self.nintendo_mastering_code: Pattern[str] = re.compile(
            '\\((?:A[BDEFNPS]|B[58DFJNPT]|CX|FT|JE|K[AFIKMRZ]|PN|QA|RC|S[KN]|T[ABCJQ]|V[BEJKLMW]|Y[XW])[ABCDEFGHIKJMLNPQSTUVWYZ0-9][DEJPVXYZ]\\)'
        )
        self.ps_firmware: Pattern[str] = re.compile('\\(FW[0-9].*?\\)', flags=re.I)
        self.ps1_2_id: Pattern[str] = re.compile('\\([SP][BCL][EKPU][ADHMNSX]-\\d{5}\\)')
        self.ps3_id: Pattern[str] = re.compile('\\([BM][CLR][AEJKTU][BCDMST]-\\d{5}\\)')
        self.ps4_id: Pattern[str] = re.compile('\\([CP][CLU][ACJKS][AMS]-\\d{5}\\)')
        self.psp_id: Pattern[str] = re.compile('\\(U[CLT][EJUS][BST]-\\d{5}\\)')
        self.psv_id: Pattern[str] = re.compile('\\(P[CS]{2}[ABEFGH]\\d{5}\\)')
        self.sega_panasonic_ring_code: Pattern[str] = re.compile(
            '\\((?:(?:[0-9]{1,2}[ABCMRS],? ?)*|R[E]?[-]?[0-9]*)\\)'
        )

        # Video standards
        self.mpal_1: Pattern[str] = re.compile('(?:-)?[( ]MPAL\\)?')
        self.ntsc_1: Pattern[str] = re.compile('(?:-)?[( ]NTSC\\)?')
        self.ntsc_2: Pattern[str] = re.compile('\\[(.*)?NTSC(.*)?\\]')
        self.ntsc_pal: Pattern[str] = re.compile('[( ]NTSC-PAL(\\))?')
        self.pal_1: Pattern[str] = re.compile(
            '( -)?[( ]PAL(?: [a-zA-Z]+| 50[Hh]z)?(?:\\)?| (?=\\())'
        )
        self.pal_2: Pattern[str] = re.compile('\\[(.*)?PAL(?!P)(.*)?\\]')
        self.pal_60: Pattern[str] = re.compile('\\(PAL 60[Hh]z\\)')
        self.secam_1: Pattern[str] = re.compile('(?:-)?[( ]SECAM\\)?')
        self.secam_2: Pattern[str] = re.compile('\\[(.*)?SECAM(.*)?\\]')

        # Other tags
        self.aftermarket: Pattern[str] = re.compile('\\(Aftermarket\\)', flags=re.I)
        self.alt: Pattern[str] = re.compile('\\(Alt.*?\\)', flags=re.I)
        self.bad: Pattern[str] = re.compile('\\[b\\]', flags=re.I)
        self.bios: Pattern[str] = re.compile('\\[BIOS\\]|\\(Enhancement Chip\\)', flags=re.I)
        self.covermount: Pattern[str] = re.compile('\\(Covermount\\)', flags=re.I)
        self.edc: Pattern[str] = re.compile('\\(EDC\\)', flags=re.I)
        self.fmtowns_marty: Pattern[str] = re.compile('\\(FM Towns Marty.*?\\)', flags=re.I)
        self.languages: Pattern[str] = re.compile('\\(((' + LANGUAGES + ')(,\\s?)?)*\\)')
        self.madein: Pattern[str] = re.compile('\\(Made in.*?\\)', flags=re.I)
        self.manuals: Pattern[str] = re.compile('\\(Manual\\)', flags=re.I)
        self.multimedia: Pattern[str] = re.compile('\\(Magazine\\)', flags=re.I)
        self.oem: Pattern[str] = re.compile('\\((?:\\w-?\\s*)*?OEM\\)', flags=re.I)
        self.pirate: Pattern[str] = re.compile('\\(Pirate\\)', flags=re.I)
        self.programs: Pattern[str] = re.compile(
            '\\((?:Test )?Program\\)|(Check|Sample) Program', flags=re.I
        )
        self.promotional: Pattern[str] = re.compile('EPK|Press Kit|\\(Promo\\)', flags=re.I)
        self.rerelease: Pattern[str] = re.compile('\\(Rerelease\\)', flags=re.I)
        self.sega32x: Pattern[str] = re.compile('\\((?:Sega |Mega-)CD 32X\\)', flags=re.I)
        self.unlicensed: Pattern[str] = re.compile('\\(Unl\\)', flags=re.I)

        # Groups for easier application
        self.dates: tuple[Pattern[str], ...] = (
            re.compile('\\(\\d{8}\\)'),
            re.compile('\\(\\d{4}-\\d{2}-\\d{2}\\)'),
            re.compile('\\(\\d{2}-\\d{2}-\\d{4}\\)'),
            re.compile('\\(\\d{2}-\\d{2}-\\d{2}\\)'),
            re.compile('\\(\\d{4}-\\d{2}-\\d{2}T\\d{6}\\)'),
            re.compile('\\((\\d{4}-\\d{2})-xx\\)'),
            re.compile('\\(~?(\\d{4})-xx-xx\\)'),
            re.compile(
                '\\((January|February|March|April|May|June|July|August|September|October|November|December),\\s?\\d{4}\\)',
                flags=re.I,
            ),
        )

        self.demos: tuple[Pattern[str], ...] = (
            re.compile('\\((?:\\w[-.]?\\s*)*Demo(?:(?:,?\\s|-)[\\w0-9\\.]*)*\\)', flags=re.I),
            re.compile('Taikenban', flags=re.I),
            re.compile('\\(@barai\\)', flags=re.I),
            re.compile('\\(GameCube Preview\\)', flags=re.I),
            re.compile('\\(Preview\\)', flags=re.I),
            re.compile('\\(Sample(?:\\s[0-9]*|\\s\\d{4}-\\d{2}-\\d{2})?\\)', flags=re.I),
            re.compile('Trial (Disc|Edition|Version|ver\\.)', flags=re.I),
            re.compile('\\((?:Full )?Trial\\)', flags=re.I),
            re.compile(
                '\\((?:\\w-?\\s*)*?Kiosk,?(?:\\s\\w*?)*\\)|Kiosk Demo Disc|(PSP System|PS2) Kiosk',
                flags=re.I,
            ),
        )

        self.mpal: tuple[Pattern[str], ...] = (self.mpal_1,)

        self.ntsc: tuple[Pattern[str], ...] = (self.ntsc_1, self.ntsc_2, self.ntsc_pal)

        self.pal: tuple[Pattern[str], ...] = (self.pal_1, self.pal_2, self.ntsc_pal)

        self.pal_60hz: tuple[Pattern[str], ...] = (self.pal_60,)

        self.secam: tuple[Pattern[str], ...] = (self.secam_1, self.secam_2)

        self.preproduction: tuple[Pattern[str], ...] = (
            self.alpha,
            self.beta,
            self.proto,
            self.preprod,
            self.dev,
        )

        self.unl_group: tuple[Pattern[str], ...] = (
            self.aftermarket,
            self.pirate,
            self.unlicensed,
        )

        self.video: tuple[Pattern[str], ...] = (
            re.compile('Game Boy Advance Video', flags=re.I),
            re.compile('- (Preview|Movie) Trailer', flags=re.I),
            re.compile('\\((?:\\w*\\s)*Trailer(?:s|\\sDisc)?(?:\\s\\w*)*\\)', flags=re.I),
        )

    def __getitem__(self, key: str) -> Any:
        return getattr(self, key)


class TitleTools:
    """Manipulates and validates titles found in DATs for use in Retool."""

    @staticmethod
    def convert_to_virtual_titles(
        title_set: set[DatNode],
        compare_groups: dict[str, set[DatNode]],
        title_group: str,
        config: Config,
    ) -> dict[str, set[DatNode]]:
        """
        Breaks compilations into into separate, virtual titles.

        Args:
            title_set (set[DatNode]): Compilation titles to be considered.

            compare_groups (dict[str, set[DatNode]]): A dictionary to store the
            virtual titles in for comparison later.

            title_group (str): The group the title should be assigned to.

            config (Config): The Retool config object.
        """
        for title in title_set:
            if title_group in ','.join([x.lower() for x in title.contains_titles]):
                # Split compilations into virtual titles
                virtual_languages: str = ''

                # Get preproduction strings out of the title
                for pattern in config.regex.preproduction:
                    preproduction_string = pattern2string(pattern, title.full_name, 0)
                    if preproduction_string:
                        preproduction_string = f' {preproduction_string}'
                        break

                # Assign properties like full names, short names, languages and priority to the virtual title
                for individual_title in title.contains_titles:
                    if '+' in title.languages_title_orig_str:
                        compilation_languages: list[str] = title.languages_title_orig_str.split('+')

                        virtual_languages = f' ({compilation_languages[title.contains_titles[individual_title]["position"] - 1]})'
                    elif title.languages:
                        virtual_languages = f' ({",".join(title.languages)})'

                    virtual_title: DatNode = deepcopy(title)

                    virtual_title.full_name = f':V: {individual_title} ({", ".join(title.regions)}){virtual_languages}{preproduction_string} • {title.full_name}'
                    virtual_title.short_name = individual_title.lower()
                    virtual_title.languages = tuple(
                        virtual_languages.strip().replace('(', '').replace(')', '').split(',')
                    )
                    virtual_title.clonelist_priority = title.contains_titles[individual_title][
                        "priority"
                    ]

                    if individual_title.lower() == title_group:
                        if virtual_title.full_name not in [
                            x.full_name for x in compare_groups[title_group]
                        ]:
                            compare_groups[title_group].add(virtual_title)

        return compare_groups

    @staticmethod
    def find_title(
        name: str,
        name_type: str,
        titles: dict[str, set[DatNode]],
        missing_titles: set[str],
        config: Config,
        deep_search: bool = False,
    ) -> set[DatNode]:
        """
        Finds titles in a dict of DatNodes, whether by short, tag free, or full name,
        or regex.

        Args:
            name (str): The name to search for.

            name_type (str): Whether to search for the `short` name,
            `regionFree` name, `full` name, or by `regex` on the full name.

            titles (dict[str, set[DatNode]]): A dictionary of DatNodes to search.

            missing_titles (set[str]): Somewhere to store searched for names that aren't
            found in the DAT file when going through `titles`. These are reported as not
            found if the user has clone list warnings turned on.

            config (Config): The Retool config object.

            deep_search (bool, optional): Usually for speed a title is searched for by
            deriving the group name from the full name. If Retool has done a certain
            amount of processing already, titles might have changed groups. A deep search
            traverses the entire dictionary for the title instead. Mandatory for a
            `match_type` of `regex`, defaults to `False`.

        Returns:
            set[DatNode]: A list of titles that match the search terms.
        """
        found_titles: set[DatNode] = set()

        if deep_search:
            # Find the title not knowing the group name
            for group in titles:
                for title in list(titles[group]):
                    if name_type == 'short' and title.short_name.lower() == name.lower():
                        found_titles.add(title)
                    elif name_type == 'full' and title.full_name.lower() == name.lower():
                        found_titles.add(title)
                    elif name_type == 'regex' and re.search(name, title.full_name.lower(), re.I):
                        found_titles.add(title)
                    elif (
                        name_type == 'regionFree' and title.region_free_name.lower() == name.lower()
                    ):
                        found_titles.add(title)
            if not found_titles:
                missing_titles.add(name)
        else:
            # Find the title by deriving the group name
            group_name: str = TitleTools.get_group_name(name, config)

            if group_name in titles:
                for title in titles[group_name]:
                    if name_type == 'short' and title.short_name.lower() == name.lower():
                        found_titles.add(title)
                    elif name_type == 'full' and title.full_name.lower() == name.lower():
                        found_titles.add(title)
                    elif name_type == 'regex' and re.search(name, title.full_name.lower(), re.I):
                        found_titles.add(title)
                    elif (
                        name_type == 'regionFree' and title.region_free_name.lower() == name.lower()
                    ):
                        found_titles.add(title)
            else:
                missing_titles.add(name)

        return found_titles

    @staticmethod
    def get_date(name: str, config: Config) -> int:
        """
        Looks for a date tag in a title's name, then returns the date in a consistent
        format.

        Args:
            name (str): A title's full name.

            config (Config): The Retool config object.

        Returns:
            int: The date in a consistent, comparable format.
        """
        months: list[str] = [
            'january',
            'february',
            'march',
            'april',
            'may',
            'june',
            'july',
            'august',
            'september',
            'october',
            'november',
            'december',
        ]

        formatted_date: int = 0

        # Normalize YYYY-MM-xx and YYYY-xx-xx dates
        if re.search(config.regex.dates[5], name):
            name = re.sub(config.regex.dates[5], '(\\1-01)', name)

        if re.search(config.regex.dates[6], name):
            name = re.sub(config.regex.dates[6], '(\\1-01-01)', name)

        us_date: bool = False
        short_date: bool = False
        utc_date: bool = False
        time: str = '000000'

        if re.search('|'.join(months), name, flags=re.I):
            for i, month in enumerate(months):
                if i < 9:
                    name = re.sub(f'{month}, ', f'0{i + 1}-01-', name, flags=re.I)
                else:
                    name = re.sub(f'{month}, ', f'{i + 1}-01-', name, flags=re.I)

        if re.search(config.regex.dates[2], name):
            us_date = True
        if re.search(config.regex.dates[3], name):
            short_date = True
        if re.search(config.regex.dates[4], name):
            utc_date = True

        for regex in config.regex.dates:
            year: str = ''
            month = ''
            day: str = ''

            if re.search(regex, name):
                regex_search_str = pattern2string(regex, name)

                name = name.replace(regex_search_str, regex_search_str.replace('-', ''))

                regex = config.regex.dates[0]
                regex_search_str = pattern2string(regex, name)

                if short_date:
                    regex = re.compile('\\(\\d{6}\\)')
                    regex_search_str = pattern2string(regex, name)
                    if int(regex_search_str[1:-5]) < 70:
                        year = str(2000 + int(regex_search_str[1:-5]))
                    else:
                        year = str(1900 + int(regex_search_str[1:-5]))
                    month = regex_search_str[3:-3]
                    day = regex_search_str[5:-1]
                elif us_date:
                    year = regex_search_str[5:-1]
                    month = regex_search_str[1:-7]
                    day = regex_search_str[3:-5]
                elif utc_date:
                    regex = re.compile('\\(\\d{8}T\\d{6}\\)')
                    regex_search_str = pattern2string(regex, name)
                    year = regex_search_str[1:5]
                    month = regex_search_str[5:7]
                    day = regex_search_str[7:9]
                    time = regex_search_str[10:16]
                else:
                    year = regex_search_str[1:-5]
                    month = regex_search_str[5:-3]
                    day = regex_search_str[7:-1]

                if (
                    int(year) >= 1970
                    and int(month) >= 1
                    and int(month) <= 12
                    and int(day) >= 1
                    and int(day) <= 31
                ):
                    formatted_date = int(f'{year}{month}{day}{time}')
                    break

        return formatted_date

    @staticmethod
    def languages(name: str, tags: set[str], config: Config, method: str) -> str:
        """
        Identifies the languages in a title's name, and either returns just
        the languages, or returns the title's name without the languages tag.

        Args:
            name (str): A title's full name.

            config (Config): The Retool config object.

            tags: (set[str]): The title tags.

            method (str): Whether to `get` the languages from the title's
            name, or `remove` them.

        Returns:
            str: Either the name of the title with the languages tag stripped,
            or just the languages.
        """
        regex_search_str: str = ''
        result: str = ''

        if tags:
            for tag in tags:
                if pattern2string(config.regex.languages, tag):
                    regex_search_str = pattern2string(config.regex.languages, tag)
                    break
        else:
            regex_search_str = pattern2string(config.regex.languages, name)

        if regex_search_str:
            if method == 'remove':
                result = name.replace(f'{regex_search_str}', '').replace('  ', ' ').strip()

            if method == 'get':
                result = regex_search_str.strip()[1:-1]

        return result

    @staticmethod
    def regions(name: str, config: Config, method: str) -> str:
        """
        Identifies the regions in a title's name, and either returns just
        the regions, or returns the title's name without the regions tag.

        Args:
            name (str): A title's full name.

            config (Config): The Retool config object.

            method (str): Whether to `get` the languages from the title's
            name, or `remove` them.

        Returns:
            str: Either the name of the title with the region tag stripped, or
            just the regions.
        """
        regex_search_str: str = pattern2string(config.regex.region_order_default, name)

        result: str = ''

        if regex_search_str:
            regex_search_str = f' {regex_search_str}'
            if method == 'remove':
                result = name.replace(regex_search_str, '').strip()

            if method == 'get':
                result = regex_search_str.strip()[1:-1].replace('Export', 'World')

        return result

    @staticmethod
    def remove_tags(name: str, config: Config) -> str:
        """
        Removes tags found in internal-config.json that are set as "ignore tags" from
        the input title's full name. This includes the explicit `ignore_tags` array, but
        also the `promote_editions`, `demote_editions`, and `modern_editions` arrays.

        Args:
            name (str): A title's full name.

            config (Config): The Retool config object.

        Returns:
            str: The full name of the title without any ignored tags.
        """
        for tag in config.tags_ignore:
            if tag[1] == 'regex':
                name = re.sub(tag[0], '', name).strip()
            elif tag[1] == 'string':
                if tag[0] in name:
                    name = name.replace(f'{tag[0]}', '').replace('  ', ' ').strip()

        return name

    @staticmethod
    def normalize_discs(name: str, config: Config) -> str:
        """
        Renames multiple variants of "Disk", "Disc", "Disque" and more found in title
        names to the same standard to make title matching easier. The strings are defined
        in the `disc_rename` array in internal-config.json.

        Args:
            name (str): A title's full name.

            config (Config): The Retool config object.

        Returns:
            str: The full name of the title with any disc tags normalized.
        """
        for key, value in config.tags_disc_rename.items():
            if key in name:
                name = name.replace(key, value)

        return name

    @staticmethod
    def get_group_name(name: str, config: Config) -> str:
        """
        Finds the group name of a given title from one of its other names.
        A group name is generally determined by taking a name string up to the first
        instance of ' (', although some exceptions have to be made for custom versioning
        where parentheses aren't used.

        Args:
            name (str): A title's full name.

            config (Config): The Retool config object.

        Returns:
            str: The group name of the title, derived from one of its other names.
        """
        name = name.rstrip()

        if name.find('(') != -1:
            name = name[: (name.find('(') - 1)].rstrip()

        # Dreamcast version compensation
        if re.search(config.regex.dreamcast_version, name):
            name = re.sub(config.regex.dreamcast_version, '', name)

        # FM-Towns/Pippin version compensation
        if re.search(config.regex.fmtowns_pippin_version, name):
            name = re.sub(config.regex.fmtowns_pippin_version, '', name)

        # Long version compensation
        if re.search(config.regex.long_version, name):
            name = re.sub(config.regex.long_version, '', name)

        # Short version compensation
        if re.search(config.regex.version_non_parens, name):
            name = re.sub(config.regex.version_non_parens, '', name)

        # Video standard compensation
        for pattern in config.regex.ntsc:
            if re.search(pattern, name):
                name = re.sub(pattern, '', name)

        for pattern in config.regex.pal:
            if re.search(pattern, name):
                name = re.sub(pattern, '', name)

        for pattern in config.regex.pal_60hz:
            if re.search(pattern, name):
                name = re.sub(pattern, '', name)

        for pattern in config.regex.secam:
            if re.search(pattern, name):
                name = re.sub(pattern, '', name)

        return name.lower().replace('  ', ' ').strip()

    @staticmethod
    def get_region_free_name(name: str, tags: set[str], config: Config) -> str:
        """
        Finds the region-free name of a title, given its full name. This means both
        the name's regions and languages are removed.

        Args:
            name (str): A title's full name.

            tags: (set[str]): The title tags.

            config (Config): The Retool config object.

        Returns:
            str: The region-free name of the title.
        """
        original_name: str = name

        remove_regions: str = TitleTools.regions(name, config, 'remove')

        if remove_regions:
            name = remove_regions

        remove_languages = TitleTools.languages(name, tags, config, 'remove')

        if remove_languages:
            name = remove_languages

        if not name:
            name = original_name

        return name

    @staticmethod
    def get_short_name(name: str, tags: set[str], config: Config) -> str:
        """
        Finds the short name of a given title. A short name is a full name that has
        had its ignored, region, and language tags removed, and its disc names normalized.

        Among other things, the short name helps to differentiate titles that are assigned
        to the same group. For example, `Title 1 (USA) (Disc 1)` and
        `Title 1 (USA) (Disc 2)` end up in the same group, `title 1`. However the short
        names of `title 1 (disc 1)` and `title 1 (disc 2)` mean that the titles aren't
        confused with one another.

        Args:
            name (str): A title's full name.

            tags: (set[str]): The title tags.

            config (Config): The Retool config object.

        Returns:
            str: The short name of the title.
        """
        name = TitleTools.normalize_discs(name, config)
        name = TitleTools.remove_tags(name, config)
        name = TitleTools.get_region_free_name(name, tags, config).strip()

        return name.lower()

    @staticmethod
    def replace_invalid_characters(name: str, config: Config, is_header_detail: bool) -> str:
        r"""
        Removes invalid file / folder name characters from a string.

        Args:
            name (str): A title's full name, or a DAT header detail.

            config (Config): The Retool config object.

            is_header_detail (bool): Set to `True` if checking a DAT's header strings
            for invalid characters. Unlike filepaths, `/` and `\` are replaced for
            header details.

        Returns:
            str: A string with invalid characters removed.
        """
        for character in config.sanitized_characters:
            if character in name:
                if character == ':':
                    if re.search('(\\S):\\s', name):
                        name = re.sub('(\\S):\\s', '\\1 - ', name)
                    else:
                        name = name.replace(character, '-')
                elif character == '"':
                    name = name.replace(character, '\'')
                elif character == '\\':
                    if is_header_detail:
                        name = name.replace(character, '-')
                elif character == '/':
                    if is_header_detail:
                        name = name.replace(character, '-')
                else:
                    name = name.replace(character, '-')

        # For strings that start with ., use the fixed width ．instead
        if not is_header_detail:
            name = re.sub('^\\.', '．', name)  # noqa: RUF001

        return name


class TraceTools:
    """Tools to trace a title's progress throughout Retool."""

    @staticmethod
    def trace_enable(title_set: set[DatNode], trace_str: str) -> bool:
        """
        Works through a set of DatNodes to see if it contains a title the user is
        searching for. If so, enable a trace.

        Args:
            title_set (set[DatNode]): A set of DatNodes currently being processed.

            trace_str (str): The string being traced.

        Returns:
            bool: If a match for the trace string is foundm returns `True`. Otherwise,
            returns `False`.
        """
        report_on_match: bool = False

        if any(
            re.search(trace_str.lower(), d.full_name.lower(), flags=re.I) for d in list(title_set)
        ):
            report_on_match = True

        return report_on_match

    @staticmethod
    def trace_title(
        trace_reference: str,
        variable: list[str] = [],
        title_set: set[DatNode] = set(),
        keep_remove: bool = False,
    ) -> None:
        """
        Messages for when a title being traced through Retool's process is acted upon.
        Where possible, the trace calls a reference message listed here to keep the code
        in other places neater.

        Args:
            trace_reference (str): In the format `REF####`. Causes the relevant message
            print, based on its reference number.

            variable (list[str], optional): Variables that can be included in the
            reference message, or alternatively, to specify which title is being kept and
            which is being removed when comparing two titles. Defaults to `[]`.

            title_set (set[DatNode], optional): The set of DatNodes that are being
            acted upon. Defaults to `set()`.

            keep_remove (bool, optional): Whether or not to show text which indicates
            which title has been kept, and which has been removed when comparing two
            titles. Defaults to `False`.
        """
        message: str = ''
        if trace_reference == 'REF0001':
            message = f'{Font.bold}[{variable[0]}]{Font.end} Original unmodified group:'
        if trace_reference == 'REF0002':
            message = f'{Font.bold}[{variable[0]}]{Font.end} Group after taking clone list priorities into account:'
        if trace_reference == 'REF0003':
            message = f'{Font.bold}[{variable[0]}]{Font.end} Group after cleaning up preproduction/bad/pirate/mixed version-revision titles:'
        if trace_reference == 'REF0004':
            message = (
                f'{Font.bold}[{variable[0]}]{Font.end} Group after handling modern title rips:'
            )
        if trace_reference == 'REF0005':
            message = f'{Font.bold}[{variable[0]}]{Font.end} [First pass] Group after filtering by user language order:'
        if trace_reference == 'REF0006':
            message = f'{Font.bold}[{variable[0]}]{Font.end} Group after handling special editions:'
        if trace_reference == 'REF0007':
            message = (
                f'{Font.bold}[{variable[0]}]{Font.end} Group after handling versions and revisions:'
            )
        if trace_reference == 'REF0008':
            message = (
                f'{Font.bold}[{variable[0]}]{Font.end} Group after handling modern title rips:'
            )
        if trace_reference == 'REF0009':
            message = f'{Font.bold}[{variable[0]}]{Font.end} Group after choosing dates:'
        if trace_reference == 'REF0010':
            message = f'{Font.bold}[{variable[0]}]{Font.end} Group after choosing good, original versions over alternatives:'
        if trace_reference == 'REF0011':
            message = f'{Font.bold}[{variable[0]}]{Font.end} Group after handling promotions and demotions:'
        if trace_reference == 'REF0012':
            message = f'{Font.bold}[{variable[0]}]{Font.end} Group after handling "Made in" titles:'
        if trace_reference == 'REF0013':
            message = f'{Font.bold}[{variable[0]}]{Font.end} Cross region parents:'
        if trace_reference == 'REF0014':
            message = f'{Font.bold}[{variable[0]}]{Font.end} Group after lower priority region, non-superset clones removed:'
        if trace_reference == 'REF0015':
            message = f'{Font.bold}[{variable[0]}]{Font.end} Highest language priority titles:'
        if trace_reference == 'REF0016':
            message = f'{Font.warning_bold}Top superset title for tag free name {variable[1]}: {variable[0]}'
        if trace_reference == 'REF0017':
            message = 'Top superset title/s for group:'
        if trace_reference == 'REF0018':
            message = f'{Font.bold}[{variable[0]}]{Font.end} Group after production title check:'
        if trace_reference == 'REF0019':
            message = f'{Font.bold}[{variable[0]}]{Font.end} {Font.success_bold}ACTION: Clone assignments (might be reassigned later):'
        if trace_reference == 'REF0020':
            message = 'ACTION: Compare clone list priority:'
        if trace_reference == 'REF0021':
            message = 'ACTION: Compare clone list priority:'
        if trace_reference == 'REF0022':
            message = 'ACTION: Compare clone list priority (both titles are supersets):'
        if trace_reference == 'REF0023':
            message = 'ACTION: Compare clone list priority (both titles are supersets):'
        if trace_reference == 'REF0024':
            message = 'ACTION: Compare dates:'
        if trace_reference == 'REF0025':
            message = 'ACTION: Compare dates:'
        if trace_reference == 'REF0026':
            message = 'ACTION: Compare dates:'
        if trace_reference == 'REF0027':
            message = 'ACTION: Compare dates:'
        if trace_reference == 'REF0028':
            message = f'Compare languages\nUser language order: {variable[0]}'
        if trace_reference == 'REF0029':
            message = f'Compare languages\nUser language order: {variable[0]}'
        if trace_reference == 'REF0030':
            message = 'ACTION: Favor multiple regions higher up user region order:'
        if trace_reference == 'REF0031':
            message = 'ACTION: Favor multiple regions higher up user region order:'
        if trace_reference == 'REF0032':
            message = 'ACTION: Choose title with string:'
        if trace_reference == 'REF0033':
            message = 'ACTION: Choose title without string:'
        if trace_reference == 'REF0034':
            message = 'ACTION: Choose title with string:'
        if trace_reference == 'REF0035':
            message = 'ACTION: Choose title without string:'
        if trace_reference == 'REF0036':
            message = 'ACTION: Choose "Made in" title:'
        if trace_reference == 'REF0037':
            message = 'ACTION: Choose "Made in" title:'
        if trace_reference == 'REF0038':
            message = 'ACTION: Choose higher versions:'
        if trace_reference == 'REF0039':
            message = 'ACTION: Choose higher versions:'
        if trace_reference == 'REF0040':
            message = 'ACTION: Choose higher versions:'
        if trace_reference == 'REF0041':
            message = 'ACTION: Choose higher versions:'
        if trace_reference == 'REF0042':
            message = f'ACTION: Excluded due to categories: {variable[0]}'
        if trace_reference == 'REF0043':
            message = f'{Font.bold}[{variable[0]}]{Font.end} [Second pass] Group after filtering by user language order:'
        if trace_reference == 'REF0044':
            message = f'ACTION: Excluded due to a categories regex: {variable[0]}'
        if trace_reference == 'REF0045':
            message = 'ACTION: Excluded due to a system override:'
        if trace_reference == 'REF0046':
            message = 'ACTION: Excluded due to a global override:'
        if trace_reference == 'REF0047':
            message = 'ACTION: Included due to a system override:'
        if trace_reference == 'REF0048':
            message = 'ACTION: Included due to a global override:'
        if trace_reference == 'REF0049':
            message = f'ACTION: Removed due to user language filters: {variable[0]}'
        if trace_reference == 'REF0050':
            message = 'Would have been a system override exclude, but was cancelled out by a system include:'
        if trace_reference == 'REF0051':
            message = 'Would have been a global override exclude, but was cancelled out by a global include:'
        if trace_reference == 'REF0052':
            message = 'Would have been a global override exclude, but was cancelled out by a system include:'
        if trace_reference == 'REF0053':
            message = f'ACTION: Changing categories for title found in clone list {Font.bold}Categories{Font.end} object:'
        if trace_reference == 'REF0054':
            message = (
                f'ACTION: Removing title found in clone list {Font.bold}Removes{Font.end} object:'
            )
        if trace_reference == 'REF0055':
            message = f'ACTION: Moving title found in clone list {Font.bold}Variants{Font.end} object to other group:'
        if trace_reference == 'REF0056':
            message = f'ACTION: Overriding default group for title found in clone list {Font.bold}overrides{Font.end} object:'
        if trace_reference == 'REF0057':
            message = 'ACTION: Fail safe removal of title with lower string value:'
        if trace_reference == 'REF0058':
            message = 'ACTION: Fail safe removal of title with lower string value:'
        if trace_reference == 'REF0059':
            message = (
                f'{Font.bold}[{variable[0]}]{Font.end} Group after filtering by string comparison:'
            )
        if trace_reference == 'REF0060':
            message = f'{Font.bold}[{variable[0]}]{Font.end} Group after handling unlicensed/aftermarket/pirate versions:'
        if trace_reference == 'REF0061':
            message = f'{Font.bold}[{variable[0]}]{Font.end} Group after handling Alt versions:'
        if trace_reference == 'REF0062':
            message = 'ACTION: Excluded due to known MIA:'
        if trace_reference == 'REF0063':
            message = 'ACTION: Title tagged as MIA:'
        if trace_reference == 'REF0064':
            message = 'ACTION: Choose higher versions:'
        if trace_reference == 'REF0065':
            message = 'ACTION: Choose higher versions:'
        if trace_reference == 'REF0066':
            message = 'ACTION: Included due to being related to a system or global override:'
        if trace_reference == 'REF0067':
            message = f'{Font.bold}[{variable[0]}]{Font.end} Original unmodified group: \n\nVirtual titles are marked with a :V:, the original compilation title is after the •'
        if trace_reference == 'REF0068':
            message = f'{Font.bold}[{variable[0]}]{Font.end} Group after filtering by user language order:\n\nVirtual titles are marked with a :V:, the original compilation title is after the •'
        if trace_reference == 'REF0069':
            message = f'{Font.bold}[{variable[0]}]{Font.end} Group after filtering by region order:\n\nVirtual titles are marked with a :V:, the original compilation title is after the •'
        if trace_reference == 'REF0070':
            message = f'{Font.bold}[{variable[0]}]{Font.end} Group with original compilation names:'
        if trace_reference == 'REF0071':
            message = f'Contenders for crossover groups: {Font.bold}{variable[0]}{Font.end}'
        if trace_reference == 'REF0072':
            message = (
                f'Looking for this ideal combination: {Font.bold}{variable}{Font.end}\n\nFound:'
            )
        if trace_reference == 'REF0073':
            message = f'{Font.success_bold}ACTION: Compilation clone assignments'
        if trace_reference == 'REF0074':
            message = f'{Font.bold}[{variable[0]}]{Font.end} Only one title in this region, skipping filtering:'
        if trace_reference == 'REF0075':
            message = 'ACTION: Tie breaker, remove the compilation title:'
        if trace_reference == 'REF0076':
            message = f'{Font.bold}[{variable[0]}]{Font.end} Group after choosing superset titles:'
        if trace_reference == 'REF0077':
            message = 'ACTION: Choose supersets:'
        if trace_reference == 'REF0078':
            message = 'ACTION: Choose supersets:'
        if trace_reference == 'REF0079':
            message = f'{Font.bold}[{variable[0]}]{Font.end} Group after favoring multiple regions higher up user region order:'
        if trace_reference == 'REF0080':
            message = f'{Font.bold}[{variable[0]}]{Font.end} Group after filtering by clone list priority:'
        if trace_reference == 'REF0081':
            message = 'ACTION: Choose more languages:'
        if trace_reference == 'REF0082':
            message = 'ACTION: Choose more languages:'
        if trace_reference == 'REF0083':
            message = f'Fallback language comparison. Compare languages based on default region order.\nDefault region language order: {variable[0]}'
        if trace_reference == 'REF0084':
            message = f'Fallback language comparison. Compare languages based on default region order.\nDefault region language order: {variable[0]}'
        if trace_reference == 'REF0085':
            message = f'ACTION: ROM tagged as MIA in {Font.bold}{variable[0]}{Font.end}:'
        if trace_reference == 'REF0086':
            message = 'ACTION: User has region bias enabled, selecting a higher region title than the superset:'
        if trace_reference == 'REF0087':
            message = 'ACTION: Keeping superset title:'
        if trace_reference == 'REF0088':
            message = 'ACTION: Keeping superset title:'
        if trace_reference == 'REF0089':
            message = f'{Font.bold}[{variable[0]}]{Font.end} Group after filtering by user language order:\n\nVirtual titles are marked with a :V:, the original title is after the •'
        if trace_reference == 'REF0090':
            message = 'ACTION: Keeping compilation that contains another:'
        if trace_reference == 'REF0091':
            message = 'ACTION: Keeping compilation that contains another:'
        if trace_reference == 'REF0092':
            message = f'{Font.bold}[{variable[0]}]{Font.end} Group after removing preproduction:'
        if trace_reference == 'REF0093':
            message = 'ACTION: Tie breaker, remove the compilation title:'
        if trace_reference == 'REF0094':
            message = 'ACTION: Favor primary region higher up user region order (individual title vs compilation):'
        if trace_reference == 'REF0095':
            message = 'ACTION: Favor primary region higher up user region order (individual title vs compilation):'
        if trace_reference == 'REF0096':
            message = f'{Font.bold}[{variable[0]}]{Font.end} Group after choosing video standard:'
        if trace_reference == 'REF0097':
            message = f'Fallback language comparison. Compare languages based on region order.\nRegion language order: {variable[0]}'
        if trace_reference == 'REF0098':
            message = f'Fallback language comparison. Compare languages based on region order.\nRegion language order: {variable[0]}'
        if trace_reference == 'REF0099':
            message = 'ACTION: Kept due to system post filter:'
        if trace_reference == 'REF0100':
            message = 'ACTION: Kept due to global post filter:'
        if trace_reference == 'REF0101':
            message = f'{Font.bold}[{variable[0]}]{Font.end} Group after fallback user language priority check:'
        if trace_reference == 'REF0102':
            message = f'{Font.bold}[{variable[0]}]{Font.end} Group after fallback higher priority region check:'
        if trace_reference == 'REF0103':
            message = (
                f'{Font.bold}[{variable[0]}]{Font.end} Group after non-superset clones removed:'
            )
        if trace_reference == 'REF0104':
            message = f'{Font.bold}[{variable[0]}]{Font.end} Group after fallback user language priority check:'
        if trace_reference == 'REF0105':
            message = 'ACTION: Tie breaker, keep the first compilation title:'
        if trace_reference == 'REF0106':
            message = 'ACTION: Compare clone list priority (both titles are supersets):'
        if trace_reference == 'REF0107':
            message = 'ACTION: Compare clone list priority (both titles are supersets):'
        if trace_reference == 'REF0108':
            message = f'ACTION: Changing categories for title found in clone list {Font.bold}Variants{Font.end} object:'
        if trace_reference == 'REF0109':
            message = f'ACTION: Moving title found in clone list {Font.bold}Variants{Font.end} object to other group due to a condition being true:'
        if trace_reference == 'REF0110':
            message = f'ACTION: Changing a title\'s priority due to a condition in the {Font.bold}Variants{Font.end} object being true:'
        if trace_reference == 'REF0111':
            message = f'ACTION: Setting a title\'s local name due to a condition in the {Font.bold}Variants{Font.end} object being true:'
        if trace_reference == 'REF0112':
            message = f'ACTION: Marking a title as English-friendly due to an entry in the {Font.bold}Variants{Font.end} object:'
        if trace_reference == 'REF0113':
            message = f'ACTION: Marking a title as English-friendly due to a condition in the {Font.bold}Variants{Font.end} object being true:'
        if trace_reference == 'REF0114':
            message = 'ACTION: Found a superset assigned as a both a parent and clone. Setting title with the superset as a parent to the superset\'s parent to resolve the conflict:'
        if trace_reference == 'REF0115':
            message = f'ACTION: Setting a title\'s local name as defined in the {Font.bold}Variants{Font.end} object:'
        if trace_reference == 'REF0116':
            message = f'ACTION: Setting a title as a superset due to a condition in the {Font.bold}Variants{Font.end} object being true:'
        if trace_reference == 'REF0117':
            message = 'ACTION: Choose title without string:'
        if trace_reference == 'REF0118':
            message = 'ACTION: Choose title without string:'
        if trace_reference == 'REF0119':
            message = f'{Font.bold}[{variable[0]}]{Font.end} Group after good dump/production/retail check:'
        if trace_reference == 'REF0120':
            message = 'INFO: Here are the title groups in contention:'
        if trace_reference == 'REF0121':
            message = 'INFO: Here are the regions required for each group in contention:'
        if trace_reference == 'REF0122':
            message = f'INFO: Here are the combinations in groups of {variable[0]}:'
        if trace_reference == 'REF0123':
            message = 'INFO: Here are the results of the candidate selection stages:'
        if trace_reference == 'REF0124':
            message = 'INFO: Testing these candidates for consideration:'
        if trace_reference == 'REF0125':
            message = 'INFO: Test details for candidate:'
        if trace_reference == 'REF0126':
            message = f'{Font.bold}[{variable[0]}]{Font.end} Group after choosing individual title due to user preference:'
        if trace_reference == 'REF0127':
            message = f'{Font.bold}[{variable[0]}]{Font.end} Group after choosing superset:'
        if trace_reference == 'REF0128':
            message = f'{Font.bold}[{variable[0]}]{Font.end} Group after comparing compilations:'

        if trace_reference:
            eprint(
                f'\n{Font.bold}{Font.underline}{trace_reference}{Font.end}: {message}{Font.end}\n'
            )

        if title_set:
            # Superset titles can be in multiple groups, so deduping needs to be done
            reported_title_set: dict[str, DatNode] = {}

            for title in title_set:
                reported_title_set[title.full_name] = title

            title_set = set(reported_title_set.values())

            for title in sorted(title_set, key=lambda x: x.full_name):
                eprint(f'* {title.full_name}')
            eprint(f'\n{Font.disabled}Press enter to continue{Font.end}')
            input()

        if keep_remove:
            eprint(f'+ Keeping:  {variable[0]}')
            eprint(f'{Font.disabled}- Removing: {variable[1]}{Font.end}')
            eprint(f'\n{Font.disabled}Press enter to continue{Font.end}')
            input()
