from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from modules.clone_lists.clone_list import CloneList
    from modules.config.config import Config
    from modules.dat.process_dat import DatNode
    from modules.titletools import Removes

from modules.clone_lists.variants import clone_list_variants
from modules.utils import Font, eprint


def clone_list_variants_orchestrator(
    processed_titles: dict[str, set[DatNode]],
    quick_lookup: dict[str, dict[str, set[DatNode]]],
    config: Config,
    clone_list: CloneList,
    removed_titles: Removes,
    is_includes: bool = False,
) -> dict[str, set[DatNode]]:
    """
    Processes a dictionary of DatNodes and groups titles together that are the same, but
    have different names as defined by the related clone list.

    This is the primary function that deals with the fact that, for example, `Title, The
    (USA)` is equivalent to `Title, Le (France)`.

    Args:
        processed_titles (dict[str, set[DatNode]]): A work in progress dictionary of
            DatNodes, originally populated from the input DAT and actively being worked on
            by Retool.

        quick_lookup (dict[str, set[DatNode]]): A dictionary keyed by multiple title
            properties that enables quick lookup of titles. Due to the way Python
            references variables, changes made here are also reflected in
            `processed_titles`.

        config (Config): The Retool config object.

        clone_list (CloneList): The clone list for the current system.

        removed_titles (Removes): The Retool removes object, which contains and
            categorizes all the titles that have been removed from consideration. It is
            used for recovering titles defined by user includes, stats, and other output
            files generated by Retool.

        is_includes (bool, optional): Set to `True` when processing includes. Is only used
            to produce reliable reporting when performing a trace. Defaults to `False`.

    Returns:
        dict (dict[str, set[DatNode]]): A dictionary of DatNodes that has had all like
        titles grouped together as defined by the related clone list.
    """
    if clone_list.variants:
        eprint('• Processing clone list variants... ')

        report_on_match: bool = False
        warning_given: bool = False
        missing_titles: set[str] = set()
        deleted_titles: set[tuple[DatNode, str]] = set()

        for value in clone_list.variants:
            if isinstance(value, dict):
                if not (
                    'group'
                    and ('titles' in value or 'compilations' in value or 'supersets' in value)
                ):
                    if config.user_input.verbose:
                        warning_given = True
                        eprint(
                            f'* The following variants entry is invalid, as it\'s missing '
                            f'a {Font.b}group{Font.be} key and one of the following '
                            f'keys: {Font.be}titles{Font.be}, '
                            f'{Font.b}compilations{Font.be}, or '
                            f'{Font.b}supersets{Font.be}',
                            level='warning',
                        )
                        eprint(f'\n  {value}', level='warning', wrap=False)

                    if config.user_input.warningpause:
                        eprint(pause=True)
                    continue
            else:
                if config.user_input.verbose:
                    warning_given = True
                    eprint(
                        '* The following variants entry isn\'t an object and will be skipped:',
                        level='warning',
                    )
                    eprint(f'\n  {value}', level='warning', wrap=False)

                    if config.user_input.warningpause:
                        eprint(pause=True)
                continue

            title_types: list[str] = ['titles', 'compilations', 'supersets']

            for title_type in title_types:
                # Assign group-level ignores to individual titles in the clone list
                if 'ignore' in value:
                    if title_type in value:
                        for variant_title in value[title_type]:
                            if 'ignore' not in variant_title:
                                variant_title['ignore'] = True

                # Assign group-level categories to individual titles in the clone list
                if 'categories' in value:
                    if isinstance(value['categories'], list):
                        if title_type in value:
                            for variant_title in value[title_type]:
                                if 'categories' not in variant_title:
                                    variant_title['categories'] = value['categories']
                    else:
                        if config.user_input.verbose:
                            eprint(
                                '* The following variant title\'s "categories" key '
                                'isn\'t an array, so no category has been assigned:',
                                level='warning',
                            )
                            eprint(
                                f'\n  {variant_title["searchTerm"]}',
                                level='warning',
                                wrap=False,
                            )

                            if config.user_input.warningpause:
                                eprint(pause=True)

                # Process the variants
                if title_type in value:
                    clone_list_variants(
                        variant_titles=value[title_type],
                        variant_type=title_type[:-1],
                        clone_list_group_contents=value,
                        processed_titles=processed_titles,
                        quick_lookup=quick_lookup,
                        missing_titles=missing_titles,
                        deleted_titles=deleted_titles,
                        removed_titles=removed_titles,
                        is_includes=is_includes,
                        config=config,
                        report_on_match=report_on_match,
                    )

        # Delete titles from old groups, and clean up empty groups
        for title, old_group_name in deleted_titles:
            if title in processed_titles[old_group_name]:
                processed_titles[old_group_name].remove(title)

            if not processed_titles[old_group_name]:
                del processed_titles[old_group_name]

        if missing_titles and config.user_input.verbose:
            eprint(
                '\n• The following variants titles in the '
                'clone list can\'t be found in the input DAT and will '
                'be skipped:\n',
                level='warning',
            )

            for missing_title in sorted(missing_titles):
                eprint(f'  •  {missing_title}', level='warning', wrap=False)

            eprint(f'{Font.end}')

            if config.user_input.warningpause:
                eprint(pause=True)

        if (warning_given or missing_titles) and config.user_input.verbose:
            eprint('• Processing clone list variants... done')
        else:
            eprint('• Processing clone list variants... done', overwrite=True)

    return processed_titles
